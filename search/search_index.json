{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"Demo/asciinema/","title":"Asciinema","text":"<pre><code># start recording\nasciinema rec\n\n# stop recording\nexit  # or, Ctrl + d\n\n# save recording\n&lt;enter&gt;  # uploads to asciinema.org\n# or, Ctrl + c  # save locally\n\n# play recording\nasciinema play &lt;recording-filepath&gt;\n\n# cut any idle time above 2 seconds\nasciinema rec -i 2\n\n# specify filename for recording. Will save locally as default.\nasciinema rec containerization.cast\n</code></pre>"},{"location":"Demo/debugging/","title":"Debugging","text":"<pre><code># SSL cert issue, fix using macOS syntax:\n# Export the certificate\nsecurity find-certificate -a -p -c \"Zscaler Root CA\" &gt; ~/zscaler_root.pem\n\n# Update both certificate locations\nsudo cat ~/zscaler_root.pem &gt;&gt; /Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/certifi/cacert.pem\nsudo cat ~/zscaler_root.pem &gt;&gt; /Library/Frameworks/Python.framework/Versions/3.12/etc/openssl/cert.pem\n\n\n# Make sure nothing else is running\ndocker stop $(docker ps -q)\n\ndocker exec -it &lt;container_id&gt; netstat -tlnp\n</code></pre>"},{"location":"Demo/demo/","title":"Demo","text":"<p>After starting the Docker Daemon,</p> <pre><code># start asciinema recording\nasciinema rec ~/Desktop/containerization.cast -i 2\n</code></pre> <ol> <li>Show the app</li> </ol> <pre><code>cat app.py\n</code></pre> <ol> <li>Show the naive Dockerfile</li> </ol> <pre><code>cat Dockerfile.single\n</code></pre> <ol> <li>Build &amp; check size</li> </ol> <pre><code>docker build -t flask-single -f Dockerfile.single .\ndocker images | grep flask\n</code></pre> <ol> <li>Inspect layers</li> </ol> <pre><code>docker history flask-single\n</code></pre> <ol> <li>Show the multi-stage Dockerfile</li> </ol> <pre><code>cat Dockerfile.multi\n</code></pre> <ol> <li>Build &amp; compare</li> </ol> <pre><code>docker build -t flask-multi -f Dockerfile.multi .\ndocker images | grep flask\n</code></pre> <ol> <li>Inspect layers again</li> </ol> <pre><code>docker history flask-multi\n</code></pre> <ol> <li>Use dive</li> </ol> <pre><code>dive flask-multi\n</code></pre> <ol> <li>Run both images</li> </ol> <pre><code>docker run -d -p 5001:5000 flask-single\ndocker run -d -p 5002:5000 flask-multi\n</code></pre> <p>Visit:</p> <p>http://localhost:5001 (single-stage)</p> <p>http://localhost:5002 (multi-stage)</p> <p>stop containers:</p> <pre><code>docker stop $(docker ps -q)\n</code></pre>"},{"location":"Demo/demo/#scanning","title":"Scanning","text":"<pre><code>IMAGE_NAME=\"flask-single\"\ntrivy image $IMAGE_NAME\n\n# Scan with specific severity levels\ntrivy image --severity HIGH,CRITICAL $IMAGE_NAME\n\n# Generate JSON report\ntrivy image --format json --output \"scans/results-${IMAGE_NAME//[:\\/]/-}-$(date +%Y-%m-%d).json\" $IMAGE_NAME\n\n# Custom script, to summarize HIGH/CRITICAL vulnerabilities, and to use in CI/CD later.\n./trivy_vulnerability_counter.sh $IMAGE_NAME\n</code></pre>"},{"location":"Demo/demo/#docker-compose","title":"Docker-compose","text":"<pre><code># Step 1: Build using bake (faster, parallel, better caching)\n# using docker-bake.hcl\ndocker buildx bake --load\n\ncat compose.yml\n\n# resource limits\ndocker inspect &lt;container_name&gt;\ndocker stats --no-stream &lt;container_name&gt;\n\n# Step 2: Run containers (no rebuild needed, images are already loaded)\ndocker compose up\n\n# Or, just `docker compose up` directly.\n# Or, to also re-build:\n# docker compose up --build\n\n# http://localhost:5001 \u2192 single-stage container\n# http://localhost:5002 \u2192 multi-stage container\n\n# Ctrl + c, stop containers.\n\ndocker compose down\n</code></pre>"},{"location":"Demo/demo/#cleanup","title":"Cleanup","text":"<p>Optionally, show cleanup of stopped containers and images, from CLI, Docker Desktop or both.</p> <pre><code>docker images\ndocker rmi -f &lt;image-name&gt; &lt;another-image-name&gt;\n</code></pre> <pre><code># Finish asciinema\nexit\nenter\nasciinema upload ~/Desktop/containerization.cast\n</code></pre>"},{"location":"Demo/resource-limits/","title":"Verify container's resource configuration and monitor resource usage","text":""},{"location":"Demo/resource-limits/#docker-inspect","title":"Docker Inspect","text":"<p>See the configuration/limits:</p> <pre><code># Inspect a specific container\ndocker inspect &lt;container_name&gt;\n</code></pre>"},{"location":"Demo/resource-limits/#docker-stats","title":"Docker Stats","text":"<p>Monitor actual resource usage in real-time:</p> <pre><code># Show stats for all containers\n# docker stats\n\n# Show stats for specific container(s)\n# docker stats &lt;container_name&gt; [&lt;another_container_name&gt;...]\n\n# Show stats without streaming (just one snapshot)\ndocker stats --no-stream &lt;container_name&gt;\n\n# Format the output to show specific columns\n# docker stats --format \"table {{.Name}}\\t{{.CPUPerc}}\\t{{.MemUsage}}\\t{{.MemPerc}}\"\n</code></pre> <p>Example output of <code>docker stats</code>:</p> <pre><code>CONTAINER ID   NAME                CPU %     MEM USAGE / LIMIT     MEM %     NET I/O          BLOCK I/O         PIDS\n3b45678901ab   myapp              0.25%     84.5MiB / 512MiB     16.50%    656B / 656B      0B / 0B           1\n</code></pre> <p>Get container names when using docker-compose:</p> <pre><code># List containers created by docker-compose\ndocker compose ps\n\n# Then use the names with docker inspect or stats\ndocker stats &lt;service_name&gt;\n</code></pre>"},{"location":"Demo/scanning/","title":"Scanning","text":"<p>Recommendation:</p> <p>Start with Docker Scout since it's built-in, then consider Trivy for more detailed scanning. Both are free and provide comprehensive vulnerability detection.</p>"},{"location":"Demo/scanning/#docker-scout-built-in-recommended","title":"Docker Scout (Built-in, Recommended)","text":"<p>Docker Scout is now integrated into Docker Desktop and is the easiest to get started with. Requires sign-in, however.</p> <pre><code># Scan an image\ndocker scout cves &lt;image-name&gt;\n\n# Quick vulnerability summary\ndocker scout quickview &lt;image-name&gt;\n\n# Compare with base image\ndocker scout compare --to &lt;base-image&gt; &lt;your-image&gt;\n</code></pre>"},{"location":"Demo/scanning/#trivy-popular-open-source","title":"Trivy (Popular Open Source)","text":"<p>Trivy is comprehensive and easy to use.</p> <pre><code># Install via Homebrew\n# brew install trivy\n\nIMAGE_NAME=\"flask-single\"\n\n# Scan an image\ntrivy image $IMAGE_NAME\n\n# Scan with specific severity levels\ntrivy image --severity HIGH,CRITICAL $IMAGE_NAME\n\n# Generate JSON report\ntrivy image --format json --output \"scans/results-${IMAGE_NAME//[:\\/]/-}-$(date +%Y-%m-%d).json\" $IMAGE_NAME\n\n# trivy image --format json --output scans/flask-single-trivy-results.json $IMAGE_NAME\n\n# Custom script, to summarize HIGH/CRITICAL vulnerabilities, and to use in CI/CD later.\n./trivy_vulnerability_counter.sh $IMAGE_NAME\n</code></pre>"},{"location":"Overview/overview/","title":"Overview","text":""},{"location":"Overview/overview/#1-the-bad-old-days","title":"1. The Bad Old Days","text":"<ul> <li>Physical servers</li> <li>\u201cOne app per server\u201d \u2192 waste of resources</li> <li>Scaling = buying new hardware</li> </ul>"},{"location":"Overview/overview/#2-virtual-machines","title":"2. Virtual Machines","text":"<ul> <li>Multiple OS instances on one machine</li> <li>Benefits: isolation, better hardware utilization, flexibility</li> <li>Drawbacks: heavy, slow boot, duplication of OS overhead</li> </ul>"},{"location":"Overview/overview/#3-containers","title":"3. Containers","text":"<ul> <li>Share the host OS kernel \u2192 lightweight, fast</li> <li>Benefits: portability, consistency across environments, efficiency</li> <li>Example: Docker</li> </ul>"},{"location":"Overview/overview/#4-container-runtime-ecosystem","title":"4. Container Runtime &amp; Ecosystem","text":"<ul> <li>Runtimes: Docker, containerd, CRI-O</li> <li>Registries (Docker Hub, Harbor, ECR, GCR)</li> <li>Orchestration need arises \u2192 enter K8S</li> </ul>"},{"location":"Overview/overview/#5-container-orchestration","title":"5. Container Orchestration","text":"<ul> <li>Why we need it: scaling, high availability, self-healing, service discovery</li> <li>Options: K8S, Docker Swarm, Nomad</li> <li>K8S dominance today</li> </ul>"},{"location":"Overview/overview/#6-devops-containers","title":"6. DevOps &amp; Containers","text":"<ul> <li>Infrastructure as Code (IaC)</li> <li>CI/CD pipelines with containers</li> <li>GitOps for declarative deployments</li> </ul>"},{"location":"Overview/overview/#7-modern-cloud-native-landscape","title":"7. Modern Cloud-Native Landscape","text":"<ul> <li>Microservices architectures</li> <li>Service meshes (Istio, Linkerd)</li> <li>Serverless containers (Knative, AWS Fargate)</li> </ul>"},{"location":"Overview/overview/#8-best-practices","title":"8. Best Practices","text":"<ul> <li>Security (least privilege, image scanning)</li> <li>Observability (logging, metrics, tracing)</li> <li>Resource management</li> </ul>"},{"location":"Overview/overview/#9-future-of-containerization","title":"9. Future of Containerization","text":"<ul> <li>WebAssembly (Wasm) vs Containers</li> <li>Edge &amp; IoT use cases</li> <li>Containers as a building block, not the end game</li> </ul>"},{"location":"Overview/topics/","title":"Topics","text":"<ul> <li>History, compare to VM's (Hyporviser vs Daemon)</li> <li>Namespaces, CGroups</li> <li>Ecosystem</li> <li>Container runtimes (Docker, Podman, CRI-O)</li> <li>Anatomy of Dockerfile</li> <li>Dockerfile -&gt; Image -&gt; Container</li> <li>Compose</li> <li>Set resource limits in compose, inspect config and run stats to verify usage</li> <li>Bake (<code>docker buildx bake</code>), optimize build speed (parallelism, caching). HCL etc.</li> <li>K8S (and Swarm), K8S's API server makes things flow smoothly, e.g. using ArgoCD</li> <li>Registries (public/private)</li> <li>Security (Trivy scanning, CVE's, SBOM)</li> <li>CI/CD with GitHub Actions (wf with image build, scan, deploy)</li> </ul>"},{"location":"VMs-vs-Containers/clear-breakdown/","title":"Clear breakdown of Virtual Machines (VMs) vs Containers","text":""},{"location":"VMs-vs-Containers/clear-breakdown/#1-architecture","title":"1. Architecture","text":"<ul> <li> <p>VMs:</p> </li> <li> <p>Run on a hypervisor (like VMware, VirtualBox, or KVM).</p> </li> <li>Each VM contains its own full operating system plus the application and dependencies.</li> <li> <p>Structure:</p> <p><pre><code>Hardware \u2192 Host OS \u2192 Hypervisor \u2192 Guest OS \u2192 App\n</code></pre> * Containers:</p> </li> <li> <p>Run on a container engine (like Docker, containerd).</p> </li> <li>Share the host OS kernel, but have isolated environments for applications and dependencies.</li> <li> <p>Structure:</p> <pre><code>Hardware \u2192 Host OS \u2192 Container Engine \u2192 App\n</code></pre> </li> </ul>"},{"location":"VMs-vs-Containers/clear-breakdown/#2-resource-usage","title":"2. Resource Usage","text":"<ul> <li>VMs: Heavier \u2014 each VM runs a full OS, using more CPU, RAM, and storage.</li> <li>Containers: Lighter \u2014 share the OS kernel, start quickly, and require fewer resources.</li> </ul>"},{"location":"VMs-vs-Containers/clear-breakdown/#3-startup-time","title":"3. Startup Time","text":"<ul> <li>VMs: Slow \u2014 can take minutes to boot up because they start an entire OS.</li> <li>Containers: Fast \u2014 usually start in seconds.</li> </ul>"},{"location":"VMs-vs-Containers/clear-breakdown/#4-isolation","title":"4. Isolation","text":"<ul> <li>VMs: Strong isolation \u2014 each has its own OS, so compromise in one VM rarely affects others.</li> <li>Containers: Weaker isolation \u2014 share the same OS kernel, so a kernel-level exploit could affect all containers.</li> </ul>"},{"location":"VMs-vs-Containers/clear-breakdown/#5-portability","title":"5. Portability","text":"<ul> <li>VMs: Less portable \u2014 VM images are large (GBs) and hypervisor-specific.</li> <li>Containers: Highly portable \u2014 container images are smaller (MBs) and run consistently across environments.</li> </ul>"},{"location":"VMs-vs-Containers/clear-breakdown/#6-use-cases","title":"6. Use Cases","text":"<ul> <li> <p>VMs:</p> </li> <li> <p>Running multiple OS types on the same machine (Linux + Windows).</p> </li> <li>Legacy applications requiring specific OS versions.</li> <li>Strong security isolation.</li> <li> <p>Containers:</p> </li> <li> <p>Microservices and cloud-native applications.</p> </li> <li>CI/CD pipelines and rapid deployments.</li> <li>Scaling apps quickly.</li> </ul> <p>\ud83d\udca1 Rule of Thumb:</p> <ul> <li>Use VMs when you need full OS isolation or run different OSes.</li> <li>Use Containers when you want lightweight, fast, and scalable application environments.</li> </ul>"},{"location":"VMs-vs-Containers/visual-style-sheet/","title":"side-by-side visual-style sheet comparing VMs and Containers","text":"Feature Virtual Machines (VMs) \ud83d\udda5\ufe0f Containers \ud83d\udce6 Architecture Hardware \u2192 Host OS \u2192 Hypervisor \u2192 Guest OS \u2192 App Hardware \u2192 Host OS \u2192 Container Engine \u2192 App OS Each VM has its own full OS Share the host OS kernel Resource Usage Heavy \u2013 needs CPU/RAM for full OS per VM Lightweight \u2013 minimal overhead Startup Time Slow \u2013 minutes to boot Fast \u2013 seconds to start Isolation Strong \u2013 complete OS separation Moderate \u2013 shared kernel isolation Portability Large VM images (GBs), hypervisor-specific Small images (MBs), run anywhere Use Cases Run multiple OS types, legacy apps, strong security isolation Microservices, CI/CD, rapid scaling Example Tools VMware, VirtualBox, Hyper-V Docker, Podman, containerd"},{"location":"VMs-vs-Containers/vms-vs-containers/","title":"VM's vs Containers","text":"<pre><code>======================================================================\n      VIRTUAL MACHINES (VMs) \ud83d\udda5\ufe0f           VS          CONTAINERS \ud83d\udce6\n======================================================================\n\nTABLE \u2013 Quick Comparison\n----------------------------------------------------------------------\nFeature             | Virtual Machines (VMs)           | Containers\n--------------------|----------------------------------|-------------------------\nArchitecture        | Hardware \u2192 Host OS \u2192 Hypervisor  | Hardware \u2192 Host OS \u2192 Container Engine\n                    | \u2192 Guest OS \u2192 App                  | \u2192 App\nOS                  | Full OS per VM                   | Shared host OS kernel\nResource Usage      | Heavy (CPU/RAM per OS)            | Lightweight\nStartup Time        | Slow (minutes)                    | Fast (seconds)\nIsolation           | Strong (separate OS)              | Moderate (shared kernel)\nPortability         | Large images (GBs)                | Small images (MBs)\nUse Cases           | Multiple OS types, legacy apps,   | Microservices, CI/CD, rapid scaling\n                    | strong security isolation         |\nExample Tools       | VMware, VirtualBox, Hyper-V       | Docker, Podman, containerd\n----------------------------------------------------------------------\n\nARCHITECTURE \u2013 Side-by-Side Stack\n----------------------------------------------------------------------\n   VMs:                                    |   Containers:\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            |   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 Application              \u2502            |   \u2502 Application              \u2502\n   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524            |   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n   \u2502 App Dependencies         \u2502            |   \u2502 App Dependencies         \u2502\n   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524            |   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n   \u2502 Guest OS (per VM)        \u2502            |   \u2502 Container Runtime Env    \u2502\n   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524            |   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n   \u2502 Hypervisor               \u2502            |   \u2502 Container Engine         \u2502\n   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524            |   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n   \u2502 Host OS                  \u2502            |   \u2502 Host OS                  \u2502\n   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524            |   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n   \u2502 Hardware                 \u2502            |   \u2502 Hardware                 \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            |   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n----------------------------------------------------------------------\n\nSTARTUP FLOW \u2013 Layer-by-Layer\n----------------------------------------------------------------------\nVMs:                                          Containers:\n[1] Start VM                                  [1] Start container\n[2] Host OS running                           [2] Host OS running\n[3] Hypervisor allocates CPU/RAM/devices      [3] Container engine allocates CPU/RAM namespaces\n[4] Boot full Guest OS                        [4] Setup file system layers\n[5] Start OS services                         [5] Setup networking (bridge/veth)\n[6] Launch application                        [6] Launch application\n\nBoot Time: Minutes                            Boot Time: Seconds\nResource Cost: High                           Resource Cost: Low\nIsolation: Strong                             Isolation: Moderate\n----------------------------------------------------------------------\n\nRULE OF THUMB:\n- Use VMs for full OS isolation, multiple OS types, and legacy/secure workloads.\n- Use Containers for lightweight, fast, and scalable app deployments.\n======================================================================\n</code></pre>"}]}